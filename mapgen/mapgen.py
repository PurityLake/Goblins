import random
import pygame
import numpy as np
from . import utils

class MapGenPerlin(object):
    """Map generator based on perlin noise
    
    Parameters:
    width(int): width of noise generated
    height(int): height of noise generated

    Data members
    width(int): width of the noise generated
    height(int): height of the noise generated
    noise(2D list): the noise generated by the constructor
    """
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.noise = self._create_perlin_noise()

    def _create_perlin_noise(self):
        """Generates a 2D array of perlin noise"""
        return self._generate_perlin_noise(self._generate_white_noise(), 9)
    
    def _generate_white_noise(self):
        base_noise = utils.init_2d_array(self.width, self.height)
        for y in range(self.height):
            for x in range(self.width):
                base_noise[y][x] = random.random() % 1
        return base_noise
    
    def _generate_smooth_noise(self, base_noise, octave):
        smooth_noise = utils.init_2d_array(self.width, self.height)
        sample_period = 1 << octave
        sample_frequency = 1.0  / sample_period

        for i in range(self.height):
            # calculate the horizontal sampling indicies
            sample_i0 = int((i / sample_period) * sample_period)
            sample_i1 = int((sample_i0 + sample_period) % self.height)
            horizontal_blend = (i + sample_i0) * sample_frequency
            for j in range(self.width):
                # calculate virtucal sampling indices
                sample_j0 = int((j / sample_period) * sample_period)
                sample_j1 = int((sample_j0 + sample_period) % self.width)
                vertical_blend = (j + sample_j0) * sample_frequency

                # blend top two corners
                top = utils.interpolate(base_noise[sample_i0][sample_j0],
                    base_noise[sample_i1][sample_j0], horizontal_blend)

                # blend bottom two cornder
                bottom = utils.interpolate(base_noise[sample_i0][sample_j1],
                    base_noise[sample_i1][sample_j1], horizontal_blend)

                # final blend
                smooth_noise[j][i] = utils.interpolate(top, bottom, vertical_blend)
        return smooth_noise
    
    def _generate_perlin_noise(self, base_noise, octave_count):
        smooth_noise = utils.init_3d_array(self.width, self.height, octave_count)
        persitence = 1.2
        perlin_noise = utils.init_2d_array(self.width, self.height)
        amplitude = 1.0
        total_amplitude = 0.0
        
        # generate smooth noise 
        for i in range(octave_count):
            smooth_noise[i] = self._generate_smooth_noise(base_noise, i)

        # blend noise together
        for octave in reversed(range(octave_count)):
            amplitude *= persitence
            total_amplitude += amplitude

            for i in range(self.height):
                for j in range(self.width):
                    perlin_noise[j][i] += smooth_noise[octave][j][i] * amplitude

        # normalisation
        for i in range(self.height):
            for j in range(self.width):
                perlin_noise[j][i] /= total_amplitude

        return perlin_noise

class MapNode(object):
    def __init__(self, ch, width, height, walk, surf=None, bgcolor=(0, 0, 0)):
        self.ch = ch
        self.width = width
        self.height = height
        self.halfw = width / 2
        self.halfh = height / 2
        self.walk = walk
        self.surf = surf
        self.bgcolor = bgcolor
        self.surfw = 0
        self.surfh = 0
        self.halfsurfw = 0
        self.halfsurfh = 0

    def get_bgcolor(self):
        return self.bgcolor

    def set_bgcolor(self, r, g, b):
        self.bgcolor = (r, g, b)
    
    def set_surf(self, surf):
        self.surf = surf
        if surf != None:
            self.surfwidth, self.surfheight = surf.get_size()
            self.halfsurfw = self.surfwidth / 2
            self.halfsurfh = self.surfheight / 2

    def set_ch(self, ch):
        self.ch = ch

    def set_can_walk(self, b):
        self.walk = b
    
    def is_none(self):
        return self.ch == " " and self.surf == None
    
    def draw(self, screen, x, y, drawbg=True):
        if drawbg:
            pygame.draw.rect(screen, self.bgcolor, (x - self.halfw, y, self.width, self.height))
        if not self.is_none():
            screen.blit(self.surf, (x - self.halfsurfw, y))

    def can_walk(self):
        return self.walk


class Map(object):
    __slots__ = "width", "height", "gentype", "font", "fontsize", "gamedata", "chance_empty", "letters", "letters_rendered"
    
    def __init__(self, width, height, gentype, font, fontsize, gamedata, chance_empty):
        self.width = width
        self.height = height
        self.gentype = gentype
        self.letters = []
        self.letters_rendered = []
        self.font = font
        self.fontsize = fontsize
        self.gamedata = gamedata
        self.chance_empty = chance_empty
        self._generate_map_data()
    
    def _generate_map_data(self):
        tiles = self.gamedata["tiles"]
        tile_types = self.gamedata.get_tile_types()
        for i in range(len(tile_types)):
            for j in range(0, tiles[tile_types[i]].chance - 1):
                tile_types.append(tile_types[i])
        map_gen = self.gentype(self.width, self.height)
        m = max(max(line) for line in map_gen.noise)
        for i, l in enumerate(map_gen.noise):
            line = []
            line_to_draw = []
            for j, pix in enumerate(l):
                val = pix % 255 / 255
                v = pix % 255
                line_to_draw.append((v, v, v))
                if val < self.chance_empty:
                    line.append(MapNode(" ", self.fontsize, self.fontsize, False))
                else:
                    t = tiles[random.choice(tile_types)]
                    line.append(MapNode(t.char, self.fontsize, self.fontsize, t.walk, bgcolor=t.bgcolor))
            self.letters.append(line)
        symbol_dict = dict()
        for mc in tile_types:
            tile = self.gamedata["tiles"][mc]
            symbol_dict[tile.char] = self.font.render(tile.char, True, tile.color)
        symbol_dict[None] = None
        for line in self.letters:
            for i in line:
                if i.ch != " ":
                    i.set_surf(symbol_dict[i.ch])
    
    def get_symbol_map(self):
        return self.letters

    def get_symbol_blit_map(self):
        return self.letters_rendered