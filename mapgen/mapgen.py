import random
import pygame
import numpy as np
from . import utils

class MapGenPerlin(object):
    """Map generator based on perlin noise
    
    Parameters:
    width(int): width of noise generated
    height(int): height of noise generated

    Data members
    width(int): width of the noise generated
    height(int): height of the noise generated
    noise(2D list): the noise generated by the constructor
    """
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.noise = self._create_perlin_noise()

    def _create_perlin_noise(self):
        """Generates a 2D array of perlin noise"""
        return self._generate_perlin_noise(self._generate_white_noise(), 10)
    
    def _generate_white_noise(self):
        base_noise = utils.init_2d_array(self.width, self.height)
        for y in range(self.height):
            for x in range(self.width):
                base_noise[y][x] = random.random() % 1
        return base_noise
    
    def _generate_smooth_noise(self, base_noise, octave):
        smooth_noise = utils.init_2d_array(self.width, self.height)
        sample_period = 1 << octave
        sample_frequency = 1.0  / sample_period

        for i in range(self.height):
            # calculate the horizontal sampling indicies
            sample_i0 = int((i / sample_period) * sample_period)
            sample_i1 = int((sample_i0 + sample_period) % self.height)
            horizontal_blend = (i + sample_i0) * sample_frequency
            for j in range(self.width):
                # calculate virtucal sampling indices
                sample_j0 = int((j / sample_period) * sample_period)
                sample_j1 = int((sample_j0 + sample_period) % self.width)
                vertical_blend = (j + sample_j0) * sample_frequency

                # blend top two corners
                top = utils.interpolate(base_noise[sample_i0][sample_j0],
                    base_noise[sample_i1][sample_j0], horizontal_blend)

                # blend bottom two cornder
                bottom = utils.interpolate(base_noise[sample_i0][sample_j1],
                    base_noise[sample_i1][sample_j1], horizontal_blend)

                # final blend
                smooth_noise[j][i] = utils.interpolate(top, bottom, vertical_blend)
        return smooth_noise
    
    def _generate_perlin_noise(self, base_noise, octave_count):
        smooth_noise = utils.init_3d_array(self.width, self.height, octave_count)
        persitence = 1.2
        perlin_noise = utils.init_2d_array(self.width, self.height)
        amplitude = 1.0
        total_amplitude = 0.0
        
        # generate smooth noise 
        for i in range(octave_count):
            smooth_noise[i] = self._generate_smooth_noise(base_noise, i)

        # blend noise together
        for octave in reversed(range(octave_count)):
            amplitude *= persitence
            total_amplitude += amplitude

            for i in range(self.height):
                for j in range(self.width):
                    perlin_noise[j][i] += smooth_noise[octave][j][i] * amplitude

        # normalisation
        for i in range(self.height):
            for j in range(self.width):
                perlin_noise[j][i] /= total_amplitude

        return perlin_noise

class Map(object):
    def __init__(self, width, height, gentype, font, map_choices):
        self.width = width
        self.height = height
        self.gentype = gentype
        self.map_to_draw = []
        self.map_surface = None
        self.letters = []
        self.letters_rendered = []
        self.font = font
        self.map_choices = map_choices
        self._generate_map_data()
    
    def _generate_map_data(self):
        map_gen = self.gentype(self.width, self.height)
        m = max(max(line) for line in map_gen.noise)
        for i, l in enumerate(map_gen.noise):
            line = []
            line_to_draw = []
            for j, pix in enumerate(l):
                val = pix % 255 / 255
                v = pix % 255
                line_to_draw.append((v, v, v))
                if val > 0.7:
                    line.append("^")
                else:
                    line.append(random.choice(self.map_choices))
            self.letters.append(line)
            self.map_to_draw.append(line_to_draw)
        self.map_to_draw = np.array(self.map_to_draw)
        self.map_choices.append("^")
        symbol_dict = dict()
        for mc in self.map_choices:
            symbol_dict[mc] = self.font.render(mc, True, [255, 255, 255])
        self.letters_rendered = [[symbol_dict[i] for i in line] for line in self.letters]
    
    def draw_noise(self, x=0, y=0):
        if pygame.get_init():
            if self.map_surface == None:
                self.map_surface = pygame.surfarray.make_surface(self.map_to_draw)
            screen.blit(self.map_surface, (x, y))
    
    def get_symbol_map(self):
        return self.letters

    def get_symbol_blit_map(self):
        return self.letters_rendered